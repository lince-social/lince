===================================================================================================================
       Lince: Tool for registry, interconnection and automation of Needs and Contributions with open scope.        
===================================================================================================================

# Installation:
Install nix:
https://nixos.org/download

After cloning the repo:
https://github.com/lince-social/lince/archive/refs/heads/main.zip or
git clone https://github.com/lince-social/lince.git or
git clone git@github.com:lince-social/lince.git

To run lince, type on the directory you cloned it:
nix-shell

Or anywhere on your system:
nix-shell /path/to/lince

Then open your browser on the adress:
localhost:5000

# Disclamer
This project is licensed under the GNU GPLv3 license. Crowdfunding is the source of development compensation:
https://github.com/sponsors/lince-social | https://www.patreon.com/lince_social | https://www.apoia.se/lince 

Lince is tries to facilitate and automate the connection between people and resources, transforming needs and contributions into data. The gains and losses related to the interaction, such as transportation, production and services themselves, remain the responsibility of the parties involved.

===================================================================================================================
                                                  DOCUMENTATION
===================================================================================================================

@: What is Lince?
#: Lince is a tool for registry, interconnection and automation of Needs and Contributions with open scope. 

@: Ok, but what is it?
#: Lince is an app that can be used to model and/or automate personal tasks, items, computer actions, economic trades between parties... The limit is your imagination (and your wizard skills with computers). 

@: Sure...
#: I'll explain everything in detail, so follow me. I promisse the journey is worth the end, traveler.


# General Functioning

## Database:
Lince works with a database, it searches for it in .config/lince/lince.sql, if not found there, it defaults to the directory lince was cloned to, in src/db/versions/lince.sql. It is recomended to frequently backup the lince.sql file, if some error or mistake happens, your information is safe.

It is tempting to say TCITD, or 'The code is the documentation', because documentations are often not up to date and that is the best way of seeing the truth about the program. But that is not best for everyone, so this documentation in text was made. With that said, if you want to learn more about lince by reading the documentation, it is advised to also have the database declaration open: https://github.com/lince-social/lince/blob/main/src/db/schema.sql.

Firstly the tables of the database will be explained, then the ways in which they can interact with themselves and/or your/other computers:

===================================================================================================================
                                                     TABLES
===================================================================================================================


# Table: record

| record   |
| ---------|
| id       |
| quantity |
| head     |
| body     |
| location |

Lince is centered on the 'record' table, but like, according to the creator... like, what do they know?

Let's assume this is Lince's sun, it is the most capable one on the task of giving Lince life. The thing the app revolves around.

---

| record   | DATA STRUCTURE |
| ---------|----------------|
| id       | SERIAL         |
| quantity | REAL           |
| head     | TEXT           |
| body     | TEXT           |
| location | POINT          |

'id's are automatically generated.

'quantity' represents the availability of the record, if negative it is a Necessity, if positive, a Contribution, zero makes it not mean much, sometimes.

'head' and 'body' are meant to be parts of a whole, where one can be used for a short summary and the other a description, or one has all the information and the other holds tags for filtering through views. With a pubsub protocol, one can send a short information of the record, in this case it can be the head, and put the rest in the body. Only those interested in the head will ask for the body of the record. That way the minimum amount of information is sent over the network, making it faster and stuff, I think.

'location' is an important information for interactions outside of computers (they exist, it's insane) or any other use you want to give it.

---

| record   | DATA STRUCTURE | USER INPUT |
| ---------|----------------|------------|
| id       | SERIAL         |            |
| quantity | REAL           | -1         |
| head     | TEXT           | Eat Apple  |
| body     | TEXT           |            |
| location | POINT          |            |

So, for an example, imagine that you like apples and you want to create a task to eat it today.

You create a 'record', giving it '-1' to the 'quantity', for that action is a Necessity in your life right now, and 'Eat Apple' to the 'head'.

---

| record   | DATA STRUCTURE | USER INPUT | ACTUAL RECORD |
| ---------|----------------| -----------| --------------|
| id       | SERIAL         |            | 1             |
| quantity | REAL           | -1         | -1            |
| head     | TEXT           | Eat Apple  | Eat Apple     |
| body     | TEXT           |            | NULL          |
| location | POINT          |            | NULL          |

The end result, on the PostgreSQL database, is this record. In summary, fields with 'NOT NULL' that have defaults don't need to be filled, as it happens automatically.

---

| id  | quantity | head      | body | location |
|-----|----------|-----------|------|----------|
| 1   | -1       | Eat Apple | NULL | NULL     |
|     |          |           |      |          |
|     |          |           |      |          |
|     |          |           |      |          |
|     |          |           |      |          |

The theoretical apple eater in the example chose to put -1 in 'quantity' because they have a view that gives them all the records with a negative 'quantity' (quantity < 0).

So they will see the 'Eat Apple' task on that view, but more about that in a second, now look at other examples of records (rows are set horizontally now).

---

| id  | quantity | head        | body                 | location |
|-----|----------|-------------|----------------------|----------|
| 1   | -1       | Eat Apple   | NULL                 | NULL     |
| 2   | 1        | Apple       | Item, Food           | NULL     |
| 3   | 0        | Brush Teeth | Action, Hygiene      | NULL     |
| 4   | 3        | Toothbrush  | Item, Hygiene        | NULL     |
| 5   | -1       | Meditate    | Action, Spirituality | NULL     |

As you can see, there are records with different quantities, heads, and bodies. They are modeling actions and items.

The user likes to center it's filtering through the body column, seeing all actions, or all items of a certain area of their lives, like Hygiene, each in different created views.

------------------------------------------------------------------------------------------------------------------

# Table: views

| views     | DATA STRUCTURE |
|-----------|----------------|
| id        | SERIAL         |
| view      | TEXT           |
| view_name | TEXT           |

We've spoken so much about views, let's dive into them. They are essentially SQL queries, allowing you to select what columns you want to see, filtered, ordered and much more, just the way you want it.
The view column has the SQL query, the view_name has the view's name. Simple, right?

------------------------------------------------------------------------------------------------------------------

# Table: `configuration`

| Column                  | DATA STRUCTURE |
|-------------------------|----------------|
| id                      | SERIAL         |
| quantity                | REAL           |
| save_mode               | VARCHAR        |
| view_id                 | INTEGER        |
| column_information_mode | VARCHAR        |
| keymap                  | JSONB          |
| truncation              | JSONB          |
| table_query             | JSONB          |
| language                | VARCHAR        |
| timezone                | VARCHAR        |

This table is responsible for changing the behavior of Lince. The 'quantity' sets the active configuration, with the value of 1, the other rows have it 0. 'save_mode' can be automatic or manual, happening only when the user demands it, or after every database change. 'view_id' sets the rows you will see, this is a reference to the id of a row in view. 'column_information_mode' can be 'quiet', 'verbose'

------------------------------------------------------------------------------------------------------------------

# Table: `history`

| Column      | DATA STRUCTURE |
|-------------|----------------|
| id          | SERIAL         |
| record_id   | INTEGER        |
| change_time | TIMESTAMP      |
| old_quantity| REAL           |
| new_quantity| REAL           |

------------------------------------------------------------------------------------------------------------------

# Table: `karma`

| Column     | DATA STRUCTURE |
|------------|----------------|
| id         | SERIAL         |
| quantity   | INTEGER        |
| expression | TEXT           |

------------------------------------------------------------------------------------------------------------------

# Table: `frequency`

| Column       | DATA STRUCTURE |
|--------------|----------------|
| id           | SERIAL         |
| quantity     | INTEGER        |
| day_week     | REAL           |
| months       | REAL           |
| days         | REAL           |
| seconds      | REAL           |
| next_date    | TIMESTAMP      |
| finish_date  | DATE           |
| when_done    | INTEGER        |

------------------------------------------------------------------------------------------------------------------

# Table: `sum`

| Column         | DATA STRUCTURE |
|----------------|----------------|
| id             | SERIAL         |
| quantity       | INTEGER        |
| record_id      | INTEGER        |
| sum_mode       | INTEGER        |
| interval_mode  | VARCHAR        |
| interval_length| INTERVAL       |
| end_lag        | INTERVAL       |
| end_date       | TIMESTAMP      |

------------------------------------------------------------------------------------------------------------------

# Table: `command`

| Column   | DATA STRUCTURE |
|----------|----------------|
| id       | SERIAL         |
| quantity | INTEGER        |
| command  | TEXT           |

------------------------------------------------------------------------------------------------------------------

# Table: `transfer`

| Column                            | DATA STRUCTURE |
|-----------------------------------|----------------|
| id                                | SERIAL         |
| records_received                  | JSON           |
| records_contributed               | JSON           |
| receiving_agreement               | BOOL           |
| contributing_agreement            | BOOL           |
| agreement_time                    | TIMESTAMP      |
| receiving_transfer_confirmation   | BOOL           |
| contributing_transfer_confirmation| BOOL           |
| transfer_time                     | TIMESTAMP      |


===================================================================================================================
                                                      KARMA
===================================================================================================================

The 'expression' column in 'karma' table is like Lince's brain.

It is divided into two parts left and right, separated by a '='. The right side firstly has it's information changed, then it is evaluated, and passed to the left side. (What?)

Let's look at an example.

You have a record:

| COLUMN   | VALUE        |
|----------|--------------|
| id       | 1            |
| quantity | 0            |
| head     | Eat Apple    |
| body     | Action, Food |
| location |              |

If we pull the Record Quantity (rq) of this record we get zero (0). If we pull the rq1, the Record Quantity of the record with ID 1, we get zero (0).

Our karma expression can be a simple:

rq1 = -1

When the karma() function is called, every row will have it's consequence if needed. In this case the consequence is that the quantity in the record with ID 1 is now -1.

How does that happen really?

The right side of the expression, in this case '-1' is evaluated, a python eval(). The right side is now literal python, you can declare classes, pull libraries, write everything, including writing just -1. The left side of the expression, since it has only the mention of a record quantity will receive that number without problems, the quantity in the record with ID 1 is now -1.

---

# Simple Example:

Now let's say that the rq1 is still zero (0), another karma expression could be:

rq1 = rq1 -1

So now everytime karma() is called, it will diminish the quantity by one, insead of always setting it to -1.

The process is like this:

rq1 = rq1 -1

Then the rq1 is searched and replaced with it's actual value.

rq1 = 0 -1

 |
 V

rq1 = -1

---

# The Zero Case:

And what if the rq1 was 1?
In that case, it would still be one, why? Because when the right side is zero, nothing changes on the left side. That is not a bug, but a feature, that way, expressions can be ignored if they dont meet certain conditions:

rq1 = -1 * (rq1 == 10)

In this case the '(rq1 == 10)' in python will be set to False, because '(1 == 10)' is False, and when '-1 * False' is read by python it returns zero. So the record quantity will remain 1.

But what if I want it to be 0? Then you add '*' before the '=':

rq1 *= -1 * (rq1 == 10)

If rq1 is ten (10), it turns into one (1), if it is not ten (10), then it turns into zero (0).

---

# How it works, really:

A karma expression is a mix of python and regex for searching and replacing, but that is not all it can do. One of the features is to be able to run commands located in the command table.

Let's say you have a command:

| Column   | VALUE           |
|----------|-----------------|
| id       | 3               |
| quantity | 1               |
| command  | touch grass.txt | <-- touch <file> in Linux creates the file.

This command with ID 3 can be referenced in a karma expression with 'c3'.

If we have a record:

| COLUMN   | VALUE            |
|----------|------------------|
| id       | 2                |
| quantity | 1                |
| head     | Create grass.txt |
| body     | Action, Command  |
| location |                  |

We can create a semi-automation, reducing the steps, the clicks, the button presses, the time it takes to do that job:

rq2,c3 = (rq2 == 0) * 1

When the quantity in record with ID 2 is 0, the command with ID 3 is run through the computer's shell and the grass.txt is created.

---

# Automation, real automation:

But what if we want to automate everything? Like literally everything.

For that, a general enough system needs to exist. When we talk automation we talk about labor automation, time that does not need to be spent doing something. Automation is a tool, not an end, and it can be a tool for the benefit of everyone, by reducing the labor needed to satiate human needs.

Lince aims to be a tool that can model human needs and contributions to meet those needs, automating as much as possible for that goal. And the biggest source of automation in Lince, is not shortening the time it takes to give the computer an instruction, but removing the need to do it, satiating that need.

The 'frequency' table allows for rows with different frequencies to return 1 to a karma expression, activating scripts changing the values in certain cells in certain tables, let's see it in action:

| Column       | VALUE                     |
|--------------|------------               |
| id           | 6                         |
| quantity     | 1                         |
| day_week     |                           |
| months       |                           |
| days         | 1                         |
| seconds      |                           |
| next_date    | 2024-01-01 22:00:00+00:00 |
| finish_date  |                           |
| when_done    |                           |

Let's say that we are in 2024-01-01 living in a place with a +0 timezone and have a karma expression:

c3 = f6

   |
   V

c3 = 0

In that same day, when ten (10) P.M. rolls around, the time is exactly '2024-01-02 22:00:00+00:00' or after, the karma() function will receive not zero (0), but one (1) from the frequency with ID 6:

c3 = 1

The command will receive one, it will be run, the 'touch grass.tx' will be executed, the grass.txt file will be created. It achieves that by updating the date in next_date by one day, as set by the day column with value one (1) in this case.

In the TODO list, ignore if you want: make all the expressions that use a certain frequency be checked and run if needed before updating next_date. Right now one activation of a frequency negates all other expressions that need to return 1 at that frequency, because it will already have been activated and updated.

---

Until now the command was only at the left side, as something that was run because of a consequence on the right side. But, it can also be run and it's output passed as a value from the right side to the left one:

| Column   | VALUE           |
|----------|-----------------|
| id       | 7               |
| quantity | 1               |
| command  | python temperature_getter.py |

| COLUMN   | VALUE            |
|----------|------------------|
| id       | 10               |
| quantity | 0                |
| head     | Get a sweater    |
| body     | Action, Clothes  |
| location |                  |


This pseudo python script uses a weather API to get the tomorrow's lowest temperature (in Celsius, obviously) in a certain city, it then prints it to the terminal, very UNIX-like. If we have that, we can ask Lince to put that temperature inside a karma expression and use it.

rq10 = -f6 * (c7 <= 15)

Reusing a previously created frequency, we can create an expression that makes the quantity of the record with ID 10 be -1 at 22h of everyday, if the command with ID 7 returns tommorow's lowest temperature as a value equal to or less then 15. If we have a view that shows only records with a negative quantity, a person will only see the necessity of packing a sweater when tomorrow is 'cold' enough.

The possibilites are vast, limited by one's domain of computers and imagination, when combined wizardry skills arise.
